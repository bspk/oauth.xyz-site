{"version":3,"sources":["webpack://oauth.xyz/./src/pages/specs.mdx","webpack://oauth.xyz/./src/components/header.js","webpack://oauth.xyz/./src/components/layout.js"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","title","keywords","parentName","to","isMDXComponent","menuLinks","name","link","location","className","style","margin","color","textDecoration","src","alt","map","class","children","maxWidth","padding","paddingTop"],"mappings":"kQAWaA,EAAe,GACtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGX,IAFFC,EAEC,EAFDA,WACGC,GACF,yBACD,OAAO,QAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAI5E,QAAC,IAAD,CAAKC,MAAM,cAAcC,SAAU,CAAC,QAAS,gBAAiB,YAAaF,QAAQ,SACnF,2DACA,iOACA,6BACA,yBAAW,sBAAYG,WAAW,KAAvB,SAAX,2QACA,yTAA2S,sBAAYA,WAAW,KAAvB,qBAA3S,yBAAiY,sBAAYA,WAAW,KAAvB,0BAAjY,cACA,gCACA,yBAAW,sBAAYA,WAAW,KAAvB,YAAX,KAAoE,QAAC,KAAD,CAAMC,GAAG,eAAeJ,QAAQ,QAAhC,+BAApE,YAA6J,sBAAYG,WAAW,KAAvB,YAA7J,sqBAAu3B,QAAC,KAAD,CAAMC,GAAG,YAAYJ,QAAQ,QAA7B,wBAAv3B,wIACA,6cACA,kCACA,yGAA2F,sBAAYG,WAAW,KAAvB,aAA3F,KAAqJ,QAAC,KAAD,CAAMC,GAAG,eAAeJ,QAAQ,QAAhC,+BAArJ,yTAA2hB,sBAAYG,WAAW,KAAvB,YAA3hB,gGACA,yCACA,oNAAsM,sBAAYA,WAAW,KAAvB,QAAtM,SAA+P,sBAAYA,WAAW,KAAvB,YAA/P,iCAAoV,QAAC,KAAD,CAAMC,GAAG,WAAWJ,QAAQ,QAA5B,WAApV,OACA,mDACA,8HAAgH,sBAAYG,WAAW,KAAvB,QAAhH,+PAA+Z,QAAC,KAAD,CAAMC,GAAG,eAAeJ,QAAQ,QAAhC,6BAA/Z,oCACA,0HAA4G,sBAAYG,WAAW,KAAvB,QAA5G,oXACA,gCACA,suBACA,2CACA,ojBACA,kbACA,2aACA,qZACA,0BACA,0DAA4C,sBAAYA,WAAW,KAAvB,UAA5C,qLAAmR,sBAAYA,WAAW,KAAvB,gBAAnR,gUACA,kDACA,gRAAkQ,sBAAYA,WAAW,KAAvB,WAAlQ,6NAAkhB,sBAAYA,WAAW,KAAvB,gBAAlhB,kCAA4mB,sBAAYA,WAAW,KAAvB,UAA5mB,WACA,8KAAgK,sBAAYA,WAAW,KAAvB,UAAhK,MAAwN,sBAAYA,WAAW,KAAvB,cAAxN,wDAAsU,sBAAYA,WAAW,KAAvB,UAAtU,6DAAqb,sBAAYA,WAAW,KAAvB,UAArb,SAAgf,sBAAYA,WAAW,KAAvB,WAAhf,0EACA,2TACA,2BACA,yCAA2B,sBAAYA,WAAW,KAAvB,aAA3B,yLAAyQ,sBAAYA,WAAW,KAAvB,QAAzQ,sMACA,oGACA,4hBACA,qNACA,2BACA,4xBACA,gDACA,2aACA,qMACA,wDACA,yIAA2H,sBAAYA,WAAW,KAAvB,yBAA3H,6BAAyN,sBAAYA,WAAW,KAAvB,UAAzN,+FAA0W,sBAAYA,WAAW,KAAvB,SAA1W,MAAia,sBAAYA,WAAW,KAAvB,YAAja,MAA2d,sBAAYA,WAAW,KAAvB,OAA3d,+EAKJN,EAAWQ,gBAAiB,G,0FChEtBC,G,QAAY,CACZ,CACEC,KAAM,UACNC,KAAM,aAER,CACED,KAAM,WACNC,KAAM,cAER,CACED,KAAM,WACNC,KAAM,cAER,CACED,KAAM,cACNC,KAAM,iBAER,CACED,KAAM,OACNC,KAAM,UAER,CACED,KAAM,SACNC,KAAM,YAER,CACED,KAAM,YACNC,KAAM,eAER,CACED,KAAM,cACNC,KAAM,WAER,CACED,KAAM,QACNC,KAAM,aAiCd,EA7Be,SAAC,GAAD,EAAGC,SAAH,OACb,uBAAKC,UAAU,UACb,uBAAKA,UAAU,WACb,sBAAIC,MAAO,CAAEC,OAAQ,IACnB,gBAAC,KAAD,CACER,GAAG,IACHO,MAAO,CACLE,MAAO,QACPC,eAAgB,SAGlB,uBAAKC,IAAI,WAAWC,IAAI,MAAMN,UAAU,SAP1C,2BAWE,2BAEIJ,EAAUW,KAAI,SAAAT,GAAI,OACd,gBAAC,KAAD,CAAMJ,GAAII,EAAKA,MAAM,iCAArB,IAA2CA,EAAKD,WAK9D,uBAAKW,MAAM,aCvCf,EApBe,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAH,OACT,gCACE,gBAAC,EAAD,MACA,uBACER,MAAO,CACLC,OAAQ,SACRQ,SAAU,IACVC,QAAS,wBACTC,WAAY,IAGbH","file":"component---src-pages-specs-mdx-938fe55eecc8b03e2333.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/jricher/Projects/oauth.xyz-site/src/components/layout.js\";\nimport { Link } from 'gatsby';\nimport Code from \"../components/code\";\nimport SEO from '../components/seo';\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <SEO title=\"Interaction\" keywords={['oauth', 'authorization', 'security']} mdxType=\"SEO\" />\n    <h1>{`Relationship to Other Specifications`}</h1>\n    <p>{`GNAP is an attempt to pull together functionality from many different extensions and deployments of OAuth 2. Here, we'll try to map specific concepts from these different protocols into the GNAP system. `}</p>\n    <h2>{`Scopes`}</h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`scope`}</inlineCode>{` parameter in OAuth 2 lets a client specify a set of strings to describe the kind of access it wants. While GNAP allows for a much richer set of authorization details to be requested, scopes are a nice simplification for client developers talking to a known API.`}</p>\n    <p>{`GNAP allows this simplification through the use of resource handles, which can be specified by the AS and used in lieu of a resources object. After all, a scope value is nothing more than a shorthand for a specific set of authorizations being requested. So to translate an OAuth 2 request of `}<inlineCode parentName=\"p\">{`scope=foo bar baz`}</inlineCode>{`, you simply request `}<inlineCode parentName=\"p\">{`access=[foo, bar, baz]`}</inlineCode>{` instead.`}</p>\n    <h2>{`Auth Code`}</h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`redirect`}</inlineCode>{` `}<Link to=\"/interaction\" mdxType=\"Link\">{`interaction start mechanism`}</Link>{` with a `}<inlineCode parentName=\"p\">{`redirect`}</inlineCode>{` finish method allows a client to send a user to interact at the AS using HTTP redirects, and for the most part this should be indistinguishable from the authorization code flow in OAuth 2. The key difference is what gets sent in the front channel. In OAuth 2, the client has to send a lot of sensitive information through the browser, including the scopes it's asking for and the client's own identity. In GNAP, the client simply goes to an opaque URL that it is given in direct response to its request. The client doesn't add any parameters to this URL. The interaction reference returned is equivalent to the authorization code, and this is useful only in the context of `}<Link to=\"/continue\" mdxType=\"Link\">{`continuing a request`}</Link>{`. Furthermore, the hash cryptographically binds the interaction reference to a set of nonces known to the client and AS at runtime.`}</p>\n    <p>{`This type of interaction can be used for web servers, SPA's, and native applications without modification. In fact, most of the differences between these types of clients are in the ways that they can manage keys and secrets. Since the binding of keys and the mode of interaction are separated in GNAP, they can be combined in ways that make the most sense for the client at hand without changing to a different grant type like in OAuth 2.`}</p>\n    <h2>{`Device Flow`}</h2>\n    <p>{`Similarly to the authorization code grant, the device grant simply makes use of the `}<inlineCode parentName=\"p\">{`user_code`}</inlineCode>{` `}<Link to=\"/interaction\" mdxType=\"Link\">{`interaction start mechanism`}</Link>{` along with polling. There is no longer a need for a separate \"device\" endpoint because the request endpoint covers both this functionality as well as token endpoint functionality. There also does not need to be a separate URL that combines the user code and its delivery URL because the arbitrary URL in the `}<inlineCode parentName=\"p\">{`redirect`}</inlineCode>{` method can fill this need without the same security issues that a combined URL would have.`}</p>\n    <h2>{`Client Credentials`}</h2>\n    <p>{`The client credentials grant in GNAP is simply a request that does not require user interaction, nor does it require any information about the user from the client. In other words, neither a `}<inlineCode parentName=\"p\">{`user`}</inlineCode>{` nor `}<inlineCode parentName=\"p\">{`interact`}</inlineCode>{` section are included in the `}<Link to=\"/request\" mdxType=\"Link\">{`request`}</Link>{`. `}</p>\n    <h2>{`Resource Owner and Assertion`}</h2>\n    <p>{`The resource owner grant could be replicated in GNAP by presenting the user's credentials as part of the `}<inlineCode parentName=\"p\">{`user`}</inlineCode>{` section of the transaction request, or by doing a challenge-response to present the user's credentials. This would be particularly useful with cryptographic credentials like FIDO tokens. Such multi-step patterns could be written as extensions to the `}<Link to=\"/interaction\" mdxType=\"Link\">{`interaction start methods`}</Link>{` for the client to make use of.`}</p>\n    <p>{`However, even more powerfully, the client can present a wide variety of verifiable assertions in the `}<inlineCode parentName=\"p\">{`user`}</inlineCode>{` section for the AS to validate and interpret as it sees fit. Chained authorization and authentication are possible in this way, as are forms of linked delegation for cases where the client already knows who the user is and has the authority to do something on their behalf, but needs to translate the authentication to something that can be used further downstream. `}</p>\n    <h2>{`Client ID`}</h2>\n    <p>{`The client ID in OAuth 2 is important to the protocol because it allows the client to identify itself during the initial front channel requests where it cannot authenticate itself, for the most common grant types. In GNAP, the client starts talking in the back channel where it can always authenticate itself using its keys. If the AS recognizes the authentication of a specific key, it can tie the request to a set of policies bound to that key's ID. If the key has been registered with the server, the client can send a reference instead. In this way, the client instance_id acts much like the client ID used to. However, in GNAP, the key referred to by the identifier is what fundamentally defines a client instance. `}</p>\n    <h2>{`Dynamic Registration`}</h2>\n    <p>{`OAuth 2 makes the assumption that all clients have been registered with the authorization server ahead of time, and that this registration includes a wide swath of information about the client software, including its capabilities, its keys, its identity, and other items. This assumption lead to the development of the dynamic registration protocol to allow client instances to be managed at runtime, but at the cost of an additional round trip and, in some cases, a client_id that sits around long after the ephemeral client has disappeared.`}</p>\n    <p>{`In GNAP, the client has the opportunity to present all of this client information during the request. This dynamic request can be bound to keys during the transaction itself, and these keys can be created by the client instance (as would be likely in a native application). These keys identify the instance, and the AS can return an instance_id that the client can use to identify itself in future transactions. `}</p>\n    <p>{`Static registration is of course still possible, with the client or developer being issued an instance_id out of band and the client presenting that instance_id during its transaction request instead of passing client information by value. This pre-registered identifier is bound to keys and interaction methods, effectively locking down a client's runtime behavior when such a lock is desired by the AS. `}</p>\n    <p>{`And finally, an AS can decide to treat clients differently depending on if it's seen the keys before. While OAuth 2 doesn't differentiate between a static and a dynamic client, most implementations flag dynamically registered clients and allow them a lesser level of access to resources. In GNAP, the AS gets to decide this based on how much it trusts the key, and for what purposes.`}</p>\n    <h2>{`UMA`}</h2>\n    <p>{`UMA's pattern of giving the client a `}<inlineCode parentName=\"p\">{`ticket`}</inlineCode>{` to present claims for, either proactively or interactively, closely matches GNAP's transactional model. UMA's more complex resource description can be incorporated into GNAP's `}<inlineCode parentName=\"p\">{`access_token`}</inlineCode>{`  request section. If the client wants to represent the same user over time, the AS can issue a user handle much like UMA's PCT. Additionally, the RS can present a set of possible resources to the AS and get a resource reference identifier to hand back to the client, mimicking UMA's resource registration endpoint.`}</p>\n    <h2>{`Identity and OpenID Connect`}</h2>\n    <p>{`The main addition that OpenID Connect brings is the ability to pass identity information to the client directly. A fully-specified GNAP-based identity protocol could be as simple as returning an identity assertion alongside the access token using the `}<inlineCode parentName=\"p\">{`subject`}</inlineCode>{` request, much in the same way the ID Token is returned in OpenID Connect today. Similarly, the UserInfo Endpoint remains a standardized resource server that behaves the same as it does today, but requested using the `}<inlineCode parentName=\"p\">{`access_token`}</inlineCode>{` structure and a standardized `}<inlineCode parentName=\"p\">{`access`}</inlineCode>{` type.`}</p>\n    <p>{`Many of the additional mechanisms in OpenID Connect can be incorporated into the GNAP request instead of being passed through the browser, including any `}<inlineCode parentName=\"p\">{`prompt`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`login_hint`}</inlineCode>{`, or vectors of trust parameters. Additionally, the `}<inlineCode parentName=\"p\">{`claims`}</inlineCode>{` mechanism's query language can be incorporated into the `}<inlineCode parentName=\"p\">{`access`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`subject`}</inlineCode>{` portion of the request, or grafted on as its own separate parameter.`}</p>\n    <p>{`Due to changes in the workings of the protocol, many other mechanisms in OpenID Connect become unnecessary additions, including the request object and hybrid signed response modes. Many of these components were intend to overcome shortcomings in the OAuth 2 protocol that GNAP does not share. `}</p>\n    <h2>{`CIBA`}</h2>\n    <p>{`CIBA maps to GNAP's `}<inlineCode parentName=\"p\">{`user_code`}</inlineCode>{` style interaction method, since the user is going to interact with the AS using a secondary application. User information and hints about the intended account can be pushed in the `}<inlineCode parentName=\"p\">{`user`}</inlineCode>{` section of the transaction request. CIBA provides additional hints to verify the device, and these could be added as either extensions or additional parameters in the core interaction methods.`}</p>\n    <h2>{`Pushed Authorization Requests (PAR) and signed authorization responses (JARM)`}</h2>\n    <p>{`OpenID Connect's Request Object was born of a need to protect a client's request through the browser, and the hybrid flow (later generalized into JARM) provided a means to protect the authorization server's response through the browser. Both of these methods additionally allow a more rich data request through the use of a JSON object instead of plain request parameters. Pushed Authorization Requests (PAR) allow the request side of this equation to be sent in the back channel using an intent registration pattern. `}</p>\n    <p>{`GNAP's transactional model protects this same information by not sending it through the browser redirects in the first place, being built on an intent registration pattern from the ground up.`}</p>\n    <h2>{`PKCE`}</h2>\n    <p>{`PKCE effectively creates an ephemeral key that the client can prove possession of at a later part of the process. With GNAP, the same results are an automatic side effect of the transactional process. The continuation access token is something known only to the client and is never passed through the front channel, and any interaction reference returned from the interaction endpoint makes sense only in the context of a specific transaction. Furthermore, the client's own keys are bound to the transaction, making it even more difficult for an attacker to make use of a stolen interaction reference. Finally, the interaction hash prevents insertion of interaction references to unwitting clients, closing a related exploitable loophole that PKCE is a partial solution for.`}</p>\n    <h2>{`OAuth PoP, MTLS, and DPoP`}</h2>\n    <p>{`The main goal of of OAuth 2's various Proof of Possession extension work is to bind a set of runtime keys that the client can prove possession of to the token issued to the client. In GNAP, the various proof of possession mechanisms are not extensions, but a core part of the design. GNAP requires a client to bind keys during its request, and these keys are further bound to the access token by default. `}</p>\n    <p>{`Additionally, GNAP defines flexibility around different proofing mechanisms. As new methods become available across different platforms, GNAP will be able to incorporate them.`}</p>\n    <h2>{`Rich Authorization Requests (RAR)`}</h2>\n    <p>{`The Rich Authorization Request (RAR) specification is being developed in parallel with GNAP, and the content of the `}<inlineCode parentName=\"p\">{`authorization_details`}</inlineCode>{` parameter is mimics the `}<inlineCode parentName=\"p\">{`access`}</inlineCode>{` field of a GNAP request. A key difference is that GNAP does not also have to contend with `}<inlineCode parentName=\"p\">{`scope`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`resource`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`aud`}</inlineCode>{`, and other values that the RAR specification has to deal with in OAuth 2.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","import { Link, graphql } from 'gatsby'\nimport { Location } from '@reach/router';\nimport PropTypes from 'prop-types'\nimport React from 'react'\n\nconst menuLinks = [\n      {\n        name: 'Request',\n        link: '/request/'\n      },\n      {\n        name: 'Continue',\n        link: '/continue/'\n      },\n      {\n        name: 'Response',\n        link: '/response/'\n      },\n      {\n        name: 'Interaction',\n        link: '/interaction/'\n      },\n      {\n        name: 'Keys',\n        link: '/keys/'\n      },\n      {\n        name: 'Tokens',\n        link: '/tokens/'\n      },\n      {\n        name: 'Discovery',\n        link: '/discovery/'\n      },\n      {\n        name: 'Other Specs',\n        link: '/specs/'\n      },\n      {\n        name: 'About',\n        link: '/about/'\n      },\n]\n\nconst Header = ({ location }) => (\n  <div className=\"header\">\n    <div className=\"wrapper\">\n      <h1 style={{ margin: 0 }}>\n        <Link\n          to=\"/\"\n          style={{\n            color: 'white',\n            textDecoration: 'none',\n          }}\n        >\n          <img src=\"/xyz.png\" alt=\"XYZ\" className=\"logo\" />\n          XYZ: Implementing GNAP\n        </Link>\n      </h1>\n          <nav>\n            {\n              menuLinks.map(link =>\n                  <Link to={link.link}><span>&raquo;</span> {link.name}</Link>\n              )\n            }\n          </nav>\n    </div>\n    <div class=\"subnav\">\n            \n    </div>\n  </div>\n)\n\nexport default Header\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { StaticQuery, graphql } from 'gatsby'\n\nimport Header from './header'\nimport 'bootstrap/dist/css/bootstrap.css'\nimport './layout.css'\n\nconst Layout = ({ children }) => (\n      <>\n        <Header/>\n        <div\n          style={{\n            margin: '0 auto',\n            maxWidth: 960,\n            padding: '0px 1.0875rem 1.45rem',\n            paddingTop: 0,\n          }}\n        >\n          {children}\n        </div>\n      </>\n)\n\nLayout.propTypes = {\n  children: PropTypes.node.isRequired,\n}\n\nexport default Layout\n"],"sourceRoot":""}